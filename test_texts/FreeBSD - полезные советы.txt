Сергей Супрунов
FreeBSD - полезные советы

Как не «проморгать» нужную строку

Вы, думаю, помните, сколько всего выводится на экран при сборке ядра или какого-нибудь большого пакета. Постоянно наблюдать за выводом довольно скучно, а экранный буфер не всегда позволяет «отмотать» вывод до интересующего вас момента. Можно, конечно, перенаправить вывод в файл и потом изучать его сколько угодно, но в этом случае вы теряете возможность «мониторить» процесс в режиме реального времени. Проблема легко решается с помощью утилиты script:

# script /var/log/build.log
Script started, output file is /var/log/build.log
# make buildworld
&lt;. . . отображение процесса сборки . . .&gt;
# exit
exit
Script done, output file is /var/log/build.log

То есть вы всё видите на экране, но при этом весь вывод, равно как и ввод, дублируются в указанном файле. Главное, чтобы места на диске хватило. Только не забывайте, что в этот же файл попадут и управляющие символы, так что этот метод не слишком подходит для «логирования» интенсивной интерактивной работы, особенно если вам часто приходится использовать Backspace.

Удалите из системы всё лишнее

При интенсивной работе с пакетами программ в системе со временем накапливается много лишнего, например, пакеты, которые устанавливались как зависимости к уже удалённым или обновлённым приложениям. Для их удаления в «полуавтоматическом» режиме служит очень удобная утилита: pkg_cutleaves (установить её можно из портов: sysutils/pkg_cutleaves). Поскольку она использует возможности portupgrade, то эта программа также должна быть у вас установлена. Если говорить точнее, то pkg_cutleaves работает с так называемыми листовыми пакетами, т.е. с такими, которые не являются зависимостями для других, установленных в системе. Например, команда «pkg_cutleaves -lc» выведет (с краткими комментариями) список пакетов-кандидатов на удаление, среди которых будут и bash, без которой вы жить не можете, и какой-нибудь gmake, который был нужен для установки приложения, уже давно «почившего в бозе». Поэтому её работа в любом случае требует вашего пристального внимания:

# /usr/local/sbin/pkg_cutleaves -x

Package 1 of 38:
autoconf-2.59_2 - Automatically &lt;...&gt; Un*x platforms (2.59)
autoconf-2.59_2 - [keep]/(d)elete/(f)lush marked pkgs/(a)bort?
** Keeping autoconf-2.59_2.

Package 2 of 38:
bash-2.05b.007_5 - The GNU Bourne Again Shell
bash-2.05b.007_5 - [keep]/(d)elete/(f)lush marked pkgs/(a)bor


 И так по всем пакетам: если хотите оставить – просто жмёте &lt;Enter&gt;, если удалить – вводите &lt;d&gt; и потом &lt;Enter&gt;.
Понятно, что если какой-то из удаляемых пакетов «держит» другие в качестве зависимости, то эти другие сами станут «листовыми». Поскольку запускать «pkg_cutleaves -x» рекурсивно, пока не останутся только нужные пакеты, – не самое весёлое занятие, разработчики предусмотрели ещё один ключ: -R. Команда «pkg_cutleaves -R» работает аналогично приведённому выше, за тем исключением, что если в системе есть пакеты, от которых зависит только удаляемый, то они будут удалены автоматически и рекурсивно, без дополнительных вопросов. Как обычно в таких случаях, настоятельно рекомендую ознакомиться с man pkg_cutleaves и внимательно отвечать на каждый вопрос программы.

О пользе обратных кавычек

Свойство оболочки исполнять выражение в обратных кавычках (`команда`) и подставлять результат в исполняемую командную строку, предоставляет широчайшие возможности для автоматизации. Например, следующая команда выведет на экран конфигурационный файл текущего ядра, независимо от платформы и имени этого файла:

$ cat /usr/src/sys/`uname -p`/conf/`uname -i`

Ещё один пример:

$ touch arch`date "+%Y-%m-%d"`

В итоге вы получите файл с именем вида arch2006-07-21, зависящим от даты исполнения команды. При необходимости можно создавать и вложенные конструкции, например:

$ echo a`echo b\`echo c\\\`echo d\\\`c\`b`a
abcdcba

Обратите внимание на то, как приходится экранировать служебные символы для того, чтобы они «срабатывали» на нужном уровне вложенности (сам слэш тоже нуждается в экранировании, поэтому на «уровне d» мы вынуждены использовать целых три символа «\»). Наибольшую пользу обратные кавычки приносят при использовании в скриптах, автоматизирующих те или иные действия.

Обновляйте коллекцию портов без усилий

В FreeBSD 6.x появилась удобная утилита для обновления портов: portsnap. Теперь не обязательно устанавливать и настраивать cvsup, обновление дерева очень легко выполняется системными средствами:

# portsnap fetch &amp;&amp; portsnap update

 При первом запуске между этими командами понадобится ещё одна: «portsnap extract». Для автоматического скачивания обновлений (например, по расписанию cron) вместо portsnap fetch следует использовать portsnap cron. 

